{"ast":null,"code":"// src/services/candidateMatchingEngine.ts\n\n/**\n * Calculates skills match score between job requirements and candidate skills\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateSkillsMatch = (job, candidate) => {\n  if (!candidate.skills || candidate.skills.length === 0) {\n    return 0;\n  }\n\n  // Extract skill keywords from job description and requirements\n  const jobText = (job.description + ' ' + job.requirements.join(' ')).toLowerCase();\n  const candidateSkills = candidate.skills.map(skill => skill.toLowerCase());\n\n  // Find matching skills\n  const matchingSkills = candidateSkills.filter(skill => jobText.includes(skill) || job.requirements.some(req => req.toLowerCase().includes(skill)));\n\n  // Calculate percentage match\n  const matchPercentage = matchingSkills.length / candidateSkills.length;\n\n  // Bonus for having many relevant skills (max 20% bonus)\n  const skillCount = candidateSkills.length;\n  const bonusMultiplier = Math.min(1.2, 1 + (skillCount - 3) * 0.05);\n  return Math.min(1, matchPercentage * bonusMultiplier);\n};\n\n/**\n * Calculates experience title match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateExperienceMatch = (job, candidate) => {\n  if (!candidate.experience || candidate.experience.length === 0) {\n    return 0;\n  }\n  const jobTitle = job.title.toLowerCase();\n  const jobKeywords = jobTitle.split(' ');\n  let bestMatch = 0;\n  candidate.experience.forEach(exp => {\n    const expTitle = exp.title.toLowerCase();\n\n    // Direct title match\n    if (expTitle === jobTitle) {\n      bestMatch = Math.max(bestMatch, 1.0);\n      return;\n    }\n\n    // Partial keyword matching\n    const expKeywords = expTitle.split(' ');\n    const matchingKeywords = jobKeywords.filter(keyword => expKeywords.some(expKeyword => expKeyword.includes(keyword) || keyword.includes(expKeyword)));\n    const keywordMatch = matchingKeywords.length / jobKeywords.length;\n    bestMatch = Math.max(bestMatch, keywordMatch);\n  });\n  return bestMatch;\n};\n\n/**\n * Calculates years of experience match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateYearsOfExperienceMatch = (job, candidate) => {\n  if (candidate.yearsOfExperience === undefined) {\n    return 0.5; // neutral score if not specified\n  }\n\n  // Extract required years from job requirements\n  let requiredYears = 1; // default minimum\n  for (const requirement of job.requirements) {\n    const yearMatch = requirement.match(/(\\d+)\\+?\\s*years?/i);\n    if (yearMatch) {\n      requiredYears = Math.max(requiredYears, parseInt(yearMatch[1], 10));\n    }\n  }\n  const candidateYears = candidate.yearsOfExperience;\n  if (candidateYears >= requiredYears) {\n    // Full score if meets requirement, bonus for significant extra experience\n    const bonus = Math.min(0.2, (candidateYears - requiredYears) * 0.05);\n    return Math.min(1, 1 + bonus);\n  } else {\n    // Partial score if below requirement\n    return candidateYears / requiredYears;\n  }\n};\n\n/**\n * Calculates education match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateEducationMatch = (job, candidate) => {\n  if (!candidate.education || candidate.education.length === 0) {\n    return 0.3; // partial credit for experience\n  }\n  const educationReqs = job.requirements.filter(req => req.toLowerCase().includes('degree') || req.toLowerCase().includes('education') || req.toLowerCase().includes('bachelor') || req.toLowerCase().includes('master') || req.toLowerCase().includes('associate'));\n  if (educationReqs.length === 0) {\n    return 0.8; // high score if no specific education required\n  }\n  let bestMatch = 0;\n  educationReqs.forEach(req => {\n    candidate.education.forEach(edu => {\n      const reqLower = req.toLowerCase();\n      const degreeLower = edu.degree.toLowerCase();\n\n      // Check for degree level matches\n      if (reqLower.includes('bachelor') && degreeLower.includes('bachelor')) {\n        bestMatch = Math.max(bestMatch, 1.0);\n      } else if (reqLower.includes('master') && degreeLower.includes('master')) {\n        bestMatch = Math.max(bestMatch, 1.0);\n      } else if (reqLower.includes('associate') && degreeLower.includes('associate')) {\n        bestMatch = Math.max(bestMatch, 0.8);\n      } else if (reqLower.includes('degree') && degreeLower.includes('degree')) {\n        bestMatch = Math.max(bestMatch, 0.9);\n      }\n\n      // Check for field-specific matches\n      if (reqLower.includes('early childhood') && degreeLower.includes('early childhood')) {\n        bestMatch = Math.max(bestMatch, 1.0);\n      } else if (reqLower.includes('education') && degreeLower.includes('education')) {\n        bestMatch = Math.max(bestMatch, 0.9);\n      }\n    });\n  });\n  return bestMatch || 0.5; // default partial match if education exists but doesn't clearly match\n};\n\n/**\n * Calculates certifications match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateCertificationsMatch = (job, candidate) => {\n  const certReqs = job.requirements.filter(req => req.toLowerCase().includes('certif') || req.toLowerCase().includes('license') || req.toLowerCase().includes('cpr') || req.toLowerCase().includes('first aid'));\n  if (certReqs.length === 0) {\n    return 0.8; // high score if no certifications required\n  }\n  if (!candidate.certifications || candidate.certifications.length === 0) {\n    return 0;\n  }\n  const candidateCerts = candidate.certifications.map(cert => cert.toLowerCase());\n  let matchCount = 0;\n  certReqs.forEach(req => {\n    const reqLower = req.toLowerCase();\n    const hasMatch = candidateCerts.some(cert => reqLower.includes(cert) || cert.includes('cpr') || cert.includes('first aid'));\n    if (hasMatch) matchCount++;\n  });\n  return matchCount / certReqs.length;\n};\n\n/**\n * Calculates job type preference match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateJobTypeMatch = (job, candidate) => {\n  if (!candidate.preferredJobTypes || candidate.preferredJobTypes.length === 0) {\n    return 0.7; // neutral score if not specified\n  }\n  return candidate.preferredJobTypes.includes(job.type) ? 1.0 : 0.3;\n};\n\n/**\n * Main function to calculate overall match score for a candidate against a job\n * Uses specified weights: Skills (25%), Experience Title Match (25%), Years (20%), Education (15%), Certifications (10%), Job Type (5%)\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Match score from 0 to 100\n */\nexport const calculateMatchScore = (job, candidate) => {\n  // Calculate individual scores\n  const skillsScore = calculateSkillsMatch(job, candidate);\n  const experienceScore = calculateExperienceMatch(job, candidate);\n  const yearsScore = calculateYearsOfExperienceMatch(job, candidate);\n  const educationScore = calculateEducationMatch(job, candidate);\n  const certificationsScore = calculateCertificationsMatch(job, candidate);\n  const jobTypeScore = calculateJobTypeMatch(job, candidate);\n\n  // Apply weights as specified\n  const weightedScore = skillsScore * 0.25 +\n  // Skills: 25%\n  experienceScore * 0.25 +\n  // Experience Title Match: 25%\n  yearsScore * 0.20 +\n  // Years of Experience: 20%\n  educationScore * 0.15 +\n  // Education: 15%\n  certificationsScore * 0.10 +\n  // Certifications: 10%\n  jobTypeScore * 0.05; // Job Type Preference: 5%\n\n  // Convert to 0-100 scale and round to whole number\n  return Math.round(weightedScore * 100);\n};","map":{"version":3,"names":["calculateSkillsMatch","job","candidate","skills","length","jobText","description","requirements","join","toLowerCase","candidateSkills","map","skill","matchingSkills","filter","includes","some","req","matchPercentage","skillCount","bonusMultiplier","Math","min","calculateExperienceMatch","experience","jobTitle","title","jobKeywords","split","bestMatch","forEach","exp","expTitle","max","expKeywords","matchingKeywords","keyword","expKeyword","keywordMatch","calculateYearsOfExperienceMatch","yearsOfExperience","undefined","requiredYears","requirement","yearMatch","match","parseInt","candidateYears","bonus","calculateEducationMatch","education","educationReqs","edu","reqLower","degreeLower","degree","calculateCertificationsMatch","certReqs","certifications","candidateCerts","cert","matchCount","hasMatch","calculateJobTypeMatch","preferredJobTypes","type","calculateMatchScore","skillsScore","experienceScore","yearsScore","educationScore","certificationsScore","jobTypeScore","weightedScore","round"],"sources":["/Users/kenanfranklin/Sites/daycare-react/src/services/candidateMatchingEngine.ts"],"sourcesContent":["// src/services/candidateMatchingEngine.ts\n\nimport { Job, UserProfile } from '../types/data';\n\n/**\n * Calculates skills match score between job requirements and candidate skills\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateSkillsMatch = (job: Job, candidate: UserProfile): number => {\n  if (!candidate.skills || candidate.skills.length === 0) {\n    return 0;\n  }\n\n  // Extract skill keywords from job description and requirements\n  const jobText = (job.description + ' ' + job.requirements.join(' ')).toLowerCase();\n  const candidateSkills = candidate.skills.map(skill => skill.toLowerCase());\n\n  // Find matching skills\n  const matchingSkills = candidateSkills.filter(skill =>\n    jobText.includes(skill) ||\n    job.requirements.some(req => req.toLowerCase().includes(skill))\n  );\n\n  // Calculate percentage match\n  const matchPercentage = matchingSkills.length / candidateSkills.length;\n  \n  // Bonus for having many relevant skills (max 20% bonus)\n  const skillCount = candidateSkills.length;\n  const bonusMultiplier = Math.min(1.2, 1 + (skillCount - 3) * 0.05);\n\n  return Math.min(1, matchPercentage * bonusMultiplier);\n};\n\n/**\n * Calculates experience title match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateExperienceMatch = (job: Job, candidate: UserProfile): number => {\n  if (!candidate.experience || candidate.experience.length === 0) {\n    return 0;\n  }\n\n  const jobTitle = job.title.toLowerCase();\n  const jobKeywords = jobTitle.split(' ');\n\n  let bestMatch = 0;\n\n  candidate.experience.forEach(exp => {\n    const expTitle = exp.title.toLowerCase();\n\n    // Direct title match\n    if (expTitle === jobTitle) {\n      bestMatch = Math.max(bestMatch, 1.0);\n      return;\n    }\n\n    // Partial keyword matching\n    const expKeywords = expTitle.split(' ');\n    const matchingKeywords = jobKeywords.filter(keyword =>\n      expKeywords.some(expKeyword =>\n        expKeyword.includes(keyword) || keyword.includes(expKeyword)\n      )\n    );\n\n    const keywordMatch = matchingKeywords.length / jobKeywords.length;\n    bestMatch = Math.max(bestMatch, keywordMatch);\n  });\n\n  return bestMatch;\n};\n\n/**\n * Calculates years of experience match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateYearsOfExperienceMatch = (job: Job, candidate: UserProfile): number => {\n  if (candidate.yearsOfExperience === undefined) {\n    return 0.5; // neutral score if not specified\n  }\n\n  // Extract required years from job requirements\n  let requiredYears = 1; // default minimum\n  for (const requirement of job.requirements) {\n    const yearMatch = requirement.match(/(\\d+)\\+?\\s*years?/i);\n    if (yearMatch) {\n      requiredYears = Math.max(requiredYears, parseInt(yearMatch[1], 10));\n    }\n  }\n\n  const candidateYears = candidate.yearsOfExperience;\n\n  if (candidateYears >= requiredYears) {\n    // Full score if meets requirement, bonus for significant extra experience\n    const bonus = Math.min(0.2, (candidateYears - requiredYears) * 0.05);\n    return Math.min(1, 1 + bonus);\n  } else {\n    // Partial score if below requirement\n    return candidateYears / requiredYears;\n  }\n};\n\n/**\n * Calculates education match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateEducationMatch = (job: Job, candidate: UserProfile): number => {\n  if (!candidate.education || candidate.education.length === 0) {\n    return 0.3; // partial credit for experience\n  }\n\n  const educationReqs = job.requirements.filter(req =>\n    req.toLowerCase().includes('degree') ||\n    req.toLowerCase().includes('education') ||\n    req.toLowerCase().includes('bachelor') ||\n    req.toLowerCase().includes('master') ||\n    req.toLowerCase().includes('associate')\n  );\n\n  if (educationReqs.length === 0) {\n    return 0.8; // high score if no specific education required\n  }\n\n  let bestMatch = 0;\n\n  educationReqs.forEach(req => {\n    candidate.education!.forEach(edu => {\n      const reqLower = req.toLowerCase();\n      const degreeLower = edu.degree.toLowerCase();\n\n      // Check for degree level matches\n      if (reqLower.includes('bachelor') && degreeLower.includes('bachelor')) {\n        bestMatch = Math.max(bestMatch, 1.0);\n      } else if (reqLower.includes('master') && degreeLower.includes('master')) {\n        bestMatch = Math.max(bestMatch, 1.0);\n      } else if (reqLower.includes('associate') && degreeLower.includes('associate')) {\n        bestMatch = Math.max(bestMatch, 0.8);\n      } else if (reqLower.includes('degree') && degreeLower.includes('degree')) {\n        bestMatch = Math.max(bestMatch, 0.9);\n      }\n\n      // Check for field-specific matches\n      if (reqLower.includes('early childhood') && degreeLower.includes('early childhood')) {\n        bestMatch = Math.max(bestMatch, 1.0);\n      } else if (reqLower.includes('education') && degreeLower.includes('education')) {\n        bestMatch = Math.max(bestMatch, 0.9);\n      }\n    });\n  });\n\n  return bestMatch || 0.5; // default partial match if education exists but doesn't clearly match\n};\n\n/**\n * Calculates certifications match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateCertificationsMatch = (job: Job, candidate: UserProfile): number => {\n  const certReqs = job.requirements.filter(req =>\n    req.toLowerCase().includes('certif') ||\n    req.toLowerCase().includes('license') ||\n    req.toLowerCase().includes('cpr') ||\n    req.toLowerCase().includes('first aid')\n  );\n\n  if (certReqs.length === 0) {\n    return 0.8; // high score if no certifications required\n  }\n\n  if (!candidate.certifications || candidate.certifications.length === 0) {\n    return 0;\n  }\n\n  const candidateCerts = candidate.certifications.map(cert => cert.toLowerCase());\n  let matchCount = 0;\n\n  certReqs.forEach(req => {\n    const reqLower = req.toLowerCase();\n    const hasMatch = candidateCerts.some(cert =>\n      reqLower.includes(cert) || cert.includes('cpr') || cert.includes('first aid')\n    );\n    if (hasMatch) matchCount++;\n  });\n\n  return matchCount / certReqs.length;\n};\n\n/**\n * Calculates job type preference match score\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Score from 0 to 1\n */\nconst calculateJobTypeMatch = (job: Job, candidate: UserProfile): number => {\n  if (!candidate.preferredJobTypes || candidate.preferredJobTypes.length === 0) {\n    return 0.7; // neutral score if not specified\n  }\n\n  return candidate.preferredJobTypes.includes(job.type) ? 1.0 : 0.3;\n};\n\n/**\n * Main function to calculate overall match score for a candidate against a job\n * Uses specified weights: Skills (25%), Experience Title Match (25%), Years (20%), Education (15%), Certifications (10%), Job Type (5%)\n * @param job - The job posting\n * @param candidate - The candidate profile\n * @returns Match score from 0 to 100\n */\nexport const calculateMatchScore = (job: Job, candidate: UserProfile): number => {\n  // Calculate individual scores\n  const skillsScore = calculateSkillsMatch(job, candidate);\n  const experienceScore = calculateExperienceMatch(job, candidate);\n  const yearsScore = calculateYearsOfExperienceMatch(job, candidate);\n  const educationScore = calculateEducationMatch(job, candidate);\n  const certificationsScore = calculateCertificationsMatch(job, candidate);\n  const jobTypeScore = calculateJobTypeMatch(job, candidate);\n\n  // Apply weights as specified\n  const weightedScore =\n    (skillsScore * 0.25) +           // Skills: 25%\n    (experienceScore * 0.25) +       // Experience Title Match: 25%\n    (yearsScore * 0.20) +            // Years of Experience: 20%\n    (educationScore * 0.15) +        // Education: 15%\n    (certificationsScore * 0.10) +   // Certifications: 10%\n    (jobTypeScore * 0.05);           // Job Type Preference: 5%\n\n  // Convert to 0-100 scale and round to whole number\n  return Math.round(weightedScore * 100);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}